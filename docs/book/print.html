<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Taskter Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Taskter Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Taskter is a powerful, terminal-based Kanban board designed for developers, project managers, and anyone who prefers to manage their tasks directly from the command line. Built with Rust, Taskter is a lightweight and efficient tool that helps you keep track of your projects without leaving the terminal.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Kanban Board</strong>: Visualize your workflow with ToDo, In-Progress, and Done columns.</li>
<li><strong>Task Management</strong>: Add, edit, delete, and manage tasks with simple commands.</li>
<li><strong>Agent System</strong>: Automate tasks using LLM-based agents with tool-calling capabilities.</li>
<li><strong>Project Tracking</strong>: Keep track of your project's description, objectives, and key results (OKRs).</li>
<li><strong>Operation Logs</strong>: Maintain a log of all operations performed on the board.</li>
<li><strong>Interactive TUI</strong>: A user-friendly terminal interface for easy navigation and task management.</li>
</ul>
<p>This book serves as the official documentation for Taskter, providing a comprehensive guide to its features and usage. Whether you're a new user or a seasoned developer, this guide will help you get the most out of Taskter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>You can install Taskter from prebuilt packages or build from source.</p>
<h2 id="homebrew"><a class="header" href="#homebrew">Homebrew</a></h2>
<pre><code class="language-bash">brew tap tomatyss/taskter
brew install taskter
</code></pre>
<h2 id="linux-packages"><a class="header" href="#linux-packages">Linux packages</a></h2>
<p>Prebuilt <code>.deb</code> archives are generated using <code>cargo deb</code> and can be downloaded
from the GitHub release page. Install them with <code>dpkg -i</code>:</p>
<pre><code class="language-bash">sudo dpkg -i taskter_0.1.0_amd64.deb
</code></pre>
<p>For Alpine Linux there is an <code>APKBUILD</code> script in <code>packaging/apk/</code> which can be
used with <code>abuild -r</code> to produce an <code>apk</code> package.</p>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build from Source</a></h2>
<p>To build Taskter from source, you need to have Rust and Cargo installed.</p>
<ol>
<li>
<p>Clone the repository:</p>
<pre><code class="language-bash">git clone https://github.com/tomatyss/taskter.git
cd taskter
</code></pre>
</li>
<li>
<p>Build the project:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>The executable will be located at <code>target/release/taskter</code>.</p>
</li>
<li>
<p>Install the executable:
You can make <code>taskter</code> available system-wide by copying it to a directory in your system's <code>PATH</code>. For example, on macOS or Linux:</p>
<pre><code class="language-bash">sudo cp target/release/taskter /usr/local/bin/taskter
</code></pre>
<p>Alternatively, you can use <code>cargo install</code>:</p>
<pre><code class="language-bash">cargo install --path .
</code></pre>
<p>This will install the <code>taskter</code> executable in your Cargo bin directory (<code>~/.cargo/bin/</code>), which should be in your <code>PATH</code>.</p>
</li>
</ol>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>If you prefer to use Docker, you can build and run Taskter without installing Rust locally.</p>
<ol>
<li>
<p>Build the Docker image:</p>
<pre><code class="language-bash">docker build -t taskter .
</code></pre>
</li>
<li>
<p>Run the application:</p>
<pre><code class="language-bash">docker compose run --rm taskter --help
</code></pre>
<p>If you plan to use the Gemini integration for agents, you'll need to pass your API key as an environment variable:</p>
<pre><code class="language-bash">GEMINI_API_KEY=&lt;your_key&gt; docker compose run --rm taskter --help
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h1>
<p>Taskter exposes multiple subcommands. Run <code>taskter --help</code> to see the available options. The README lists common workflows.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>This section provides a quick overview of how to get started with Taskter.</p>
<h3 id="1-initialize-the-board"><a class="header" href="#1-initialize-the-board">1. Initialize the board</a></h3>
<p>First, navigate to your project's directory and initialize the Taskter board:</p>
<pre><code class="language-bash">taskter init
</code></pre>
<p>This will create a <code>.taskter</code> directory to store all your tasks, agents, and project data.</p>
<p>All operation logs are written to <code>.taskter/logs.log</code>. Inspect this file directly
or run <code>taskter logs list</code> to view the history.</p>
<h3 id="2-create-an-agent"><a class="header" href="#2-create-an-agent">2. Create an agent</a></h3>
<p>Next, create an agent to help you with your tasks. For this example, we'll create a simple agent that can run bash commands:</p>
<pre><code class="language-bash">taskter agent add --prompt "You are a helpful assistant that can run bash commands." --tools "run_bash" --model "gemini-pro"
</code></pre>
<p>You can list all available agents using:</p>
<pre><code class="language-bash">taskter agent list
</code></pre>
<p>You can list the built-in tools with:</p>
<pre><code class="language-bash">taskter tools list
</code></pre>
<h3 id="3-create-a-task"><a class="header" href="#3-create-a-task">3. Create a task</a></h3>
<p>Now, let's create a task for your agent to complete:</p>
<pre><code class="language-bash">taskter task add -t "List files in the current directory" -d "Use the ls -la command to list all files and folders in the current directory."
</code></pre>
<p>You can see all your tasks by running:</p>
<pre><code class="language-bash">taskter task list
</code></pre>
<h3 id="4-assign-the-task-to-an-agent"><a class="header" href="#4-assign-the-task-to-an-agent">4. Assign the task to an agent</a></h3>
<p>Assign the newly created task to your agent:</p>
<pre><code class="language-bash">taskter task assign --task-id 1 --agent-id 1
</code></pre>
<p>To remove the agent later:</p>
<pre><code class="language-bash">taskter task unassign --task-id 1
</code></pre>
<h3 id="5-execute-the-task"><a class="header" href="#5-execute-the-task">5. Execute the task</a></h3>
<p>Finally, execute the task:</p>
<pre><code class="language-bash">taskter task execute --task-id 1
</code></pre>
<p>The agent will now run the task. If it's successful, the task will be marked as "Done". You can view the board at any time using the interactive UI:</p>
<pre><code class="language-bash">taskter board
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tui-guide"><a class="header" href="#tui-guide">TUI Guide</a></h1>
<p>Taskter's interactive Terminal User Interface (TUI) provides a visual way to manage your Kanban board. To launch it, run:</p>
<pre><code class="language-bash">taskter board
</code></pre>
<h2 id="keybindings"><a class="header" href="#keybindings">Keybindings</a></h2>
<p>The TUI is controlled with keyboard shortcuts. Here is a list of the available keybindings:</p>
<div class="table-wrapper"><table><thead><tr><th>Key(s)</th><th>Action</th></tr></thead><tbody>
<tr><td><code>q</code></td><td>Quit the application</td></tr>
<tr><td><code>←</code> / <code>→</code> or <code>Tab</code></td><td>Navigate between columns</td></tr>
<tr><td><code>↑</code> / <code>↓</code></td><td>Navigate between tasks in a column</td></tr>
<tr><td><code>h</code> / <code>l</code></td><td>Move a selected task to the next or previous column</td></tr>
<tr><td><code>n</code></td><td>Create a new task</td></tr>
<tr><td><code>u</code></td><td>Edit the selected task</td></tr>
<tr><td><code>d</code></td><td>Delete the selected task</td></tr>
<tr><td><code>a</code></td><td>Assign an agent to the selected task</td></tr>
<tr><td><code>r</code></td><td>Unassign the selected task's agent</td></tr>
<tr><td><code>c</code></td><td>Add a comment to the selected task</td></tr>
<tr><td><code>L</code></td><td>View project logs</td></tr>
<tr><td><code>A</code></td><td>List available agents</td></tr>
<tr><td><code>O</code></td><td>Show project OKRs</td></tr>
<tr><td><code>?</code></td><td>Show available commands</td></tr>
</tbody></table>
</div>
<p>When a task is selected, you can press <code>Enter</code> to view its details, including the full description, any comments, and the assigned agent ID.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agent-system"><a class="header" href="#agent-system">Agent System</a></h1>
<p>Taskter supports LLM-based agents that can be assigned to tasks. Agents are model-agnostic via a provider layer. Gemini is the default provider today, and additional providers can be added without changing the agent loop. See <a href="providers.html">Model Providers</a>.</p>
<p>This chapter explains how the runtime coordinates models and tools, how to inspect runs, and how to extend the system.</p>
<h2 id="execution-flow"><a class="header" href="#execution-flow">Execution Flow</a></h2>
<ol>
<li><strong>Bootstrap history</strong> – Taskter combines the agent’s system prompt with the selected task (title plus description, when available) and asks the resolved provider for the next action.</li>
<li><strong>Provider response</strong> – Providers return either:
<ul>
<li><code>Text</code>: a final message, which is recorded in the task comment log and marks execution as successful.</li>
<li><code>ToolCall</code>: name, arguments, and optional <code>call_id</code>. Tool calls are executed synchronously on the host.</li>
</ul>
</li>
<li><strong>Tool execution</strong> – Built-in tools are dispatched through <code>tools::execute_tool</code>. Any failure is surfaced as an agent failure with the tool error message.</li>
<li><strong>Loop</strong> – Providers receive the tool result (including <code>call_id</code> wiring for multi-turn APIs) and the process repeats until a final text response arrives.</li>
<li><strong>Logging</strong> – High-level events are appended to <code>.taskter/logs.log</code>. Raw provider requests and responses are mirrored to <code>.taskter/api_responses.log</code> for debugging.</li>
</ol>
<p>If the provider requires an API key and none is present in the environment, Taskter enters <strong>offline simulation mode</strong>. Agents that include the <code>send_email</code> tool are treated as successful with a stubbed comment; other agents fail and explain that the required tool is unavailable. This keeps tests deterministic while signalling that a real API key is needed for end-to-end execution.</p>
<h2 id="creating-an-agent"><a class="header" href="#creating-an-agent">Creating an Agent</a></h2>
<p>You can create an agent using the <code>agent add</code> subcommand. You need to provide a prompt, a list of tools, and a model.</p>
<pre><code class="language-bash">taskter agent add --prompt "You are a helpful assistant." --tools "project_files" "run_bash" --model "gemini-2.5-pro"
</code></pre>
<p>The <code>--tools</code> option accepts either paths to JSON files describing a tool or the name of a built-in tool. Built-in tools live under <code>tools/</code> in the repository, and their declarations are bundled into the binary.</p>
<p>You can display the registry at any time with:</p>
<pre><code class="language-bash">taskter tools list
</code></pre>
<h3 id="built-in-tool-reference"><a class="header" href="#built-in-tool-reference">Built-in Tool Reference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Tool name</th><th>Purpose</th><th>Required arguments</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>run_bash</code></td><td>Execute a shell command inside the project directory</td><td><code>command</code> (string)</td><td>Returns trimmed stdout; non-zero status bubbles up as a failure</td></tr>
<tr><td><code>run_python</code></td><td>Execute inline Python and return stdout</td><td><code>code</code> (string)</td><td>Uses the system Python interpreter</td></tr>
<tr><td><code>project_files</code></td><td>Read, create, update, or search text files</td><td><code>action</code>; create/read/update: <code>path</code>; update: <code>content</code>; search: <code>query</code></td><td>Uses the supplied path verbatim (no sandbox); alias <code>file_ops</code></td></tr>
<tr><td><code>get_description</code></td><td>Retrieve the project description text from <code>.taskter/description.md</code></td><td><em>none</em></td><td>Handy for planning/reporting agents</td></tr>
<tr><td><code>send_email</code> / <code>email</code></td><td>Send email via SMTP</td><td><code>to</code>, <code>subject</code>, <code>body</code></td><td>Requires <code>.taskter/email_config.json</code>; <code>email</code> is an alias</td></tr>
<tr><td><code>taskter_task</code></td><td>Proxy to <code>taskter task …</code> CLI</td><td><code>args</code> (array of strings)</td><td>Invoke task subcommands (add, list, assign, execute, etc.)</td></tr>
<tr><td><code>taskter_agent</code></td><td>Proxy to <code>taskter agent …</code> CLI</td><td><code>args</code> (array of strings)</td><td>Manage agents programmatically</td></tr>
<tr><td><code>taskter_okrs</code></td><td>Proxy to <code>taskter okrs …</code> CLI</td><td><code>args</code> (array of strings)</td><td>Add or list OKRs</td></tr>
<tr><td><code>taskter_tools</code></td><td>Proxy to <code>taskter tools list</code></td><td><code>args</code> (array of strings)</td><td>Usually <code>["list"]</code>; useful for self-inspection</td></tr>
<tr><td><code>web_search</code></td><td>Fetch a DuckDuckGo summary</td><td><code>query</code> (string)</td><td>Respects <code>SEARCH_API_ENDPOINT</code>; requires outbound network access</td></tr>
</tbody></table>
</div>
<h2 id="assigning-an-agent-to-a-task"><a class="header" href="#assigning-an-agent-to-a-task">Assigning an Agent to a Task</a></h2>
<p>Once you have created an agent, you can assign it to a task using the <code>assign</code> subcommand:</p>
<pre><code class="language-bash">taskter task assign --task-id 1 --agent-id 1
</code></pre>
<h3 id="unassigning-an-agent"><a class="header" href="#unassigning-an-agent">Unassigning an Agent</a></h3>
<p>Remove an agent from a task without executing it:</p>
<pre><code class="language-bash">taskter task unassign --task-id 1
</code></pre>
<h2 id="executing-a-task"><a class="header" href="#executing-a-task">Executing a Task</a></h2>
<p>To execute a task with an assigned agent, use the <code>execute</code> subcommand:</p>
<pre><code class="language-bash">taskter task execute --task-id 1
</code></pre>
<p>When a task is executed, the agent will attempt to perform the task. If successful, the task is marked as "Done". If it fails, the task is moved back to "To Do", unassigned, and a comment from the agent is added.</p>
<p>In the interactive board (<code>taskter board</code>), tasks assigned to an agent will be marked with a <code>*</code>. You can view the assigned agent ID and any comments by selecting the task and pressing <code>Enter</code>.</p>
<h2 id="updating-an-agent"><a class="header" href="#updating-an-agent">Updating an Agent</a></h2>
<p>Use the <code>agent update</code> command to modify an existing agent's configuration:</p>
<pre><code class="language-bash">taskter agent update --id 1 --prompt "New prompt" --tools "taskter_task" --model "gemini-pro"
</code></pre>
<p>All three options are required and the previous configuration is overwritten.</p>
<h2 id="debugging-agent-runs"><a class="header" href="#debugging-agent-runs">Debugging Agent Runs</a></h2>
<ul>
<li><strong>High-level activity</strong> – Inspect <code>.taskter/logs.log</code> for a chronological record of agent starts, tool invocations, and outcomes.</li>
<li><strong>Provider payloads</strong> – <code>.taskter/api_responses.log</code> stores JSON requests and responses for each step; this is invaluable when bringing up a new provider or debugging schema issues.</li>
<li><strong>Exit codes</strong> – CLI commands return non-zero when execution fails, and the failure message is the same one captured in the task comment.</li>
</ul>
<h2 id="creating-custom-tools"><a class="header" href="#creating-custom-tools">Creating Custom Tools</a></h2>
<p>Agents can use custom tools in addition to the built-in ones. A tool is defined
in a JSON file with three required fields:</p>
<ul>
<li><code>name</code> – the unique identifier for the tool</li>
<li><code>description</code> – a short explanation of what the tool does</li>
<li><code>parameters</code> – JSON Schema describing the arguments</li>
</ul>
<p>An example tool definition:</p>
<pre><code class="language-json">{
  "name": "say_hello",
  "description": "Return a greeting for the provided name",
  "parameters": {
    "type": "object",
    "properties": {
      "name": { "type": "string", "description": "Name to greet" }
    },
    "required": ["name"]
  }
}
</code></pre>
<p>Save this JSON to a file, for instance <code>hello_tool.json</code>, and pass the path to
<code>taskter agent add</code>:</p>
<pre><code class="language-bash">taskter agent add --prompt "Be friendly" --tools "./hello_tool.json" --model "gemini-pro"
</code></pre>
<p>You can mix file paths and built-in tool names in the <code>--tools</code> list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheduling-agents"><a class="header" href="#scheduling-agents">Scheduling Agents</a></h1>
<p>Taskter can run agents automatically based on cron expressions. A scheduler daemon reads the agent configuration and executes the assigned tasks at the defined times.</p>
<h2 id="setting-a-schedule"><a class="header" href="#setting-a-schedule">Setting a Schedule</a></h2>
<p>Use the <code>agent schedule set</code> command to assign a cron expression to an agent. The expression is parsed in the <code>America/New_York</code> timezone.</p>
<pre><code class="language-bash"># Run every minute
taskter agent schedule set --id 1 --cron "0 * * * * *"
</code></pre>
<p>Pass <code>--once</code> to remove the schedule after the first run.</p>
<h2 id="listing-and-removing"><a class="header" href="#listing-and-removing">Listing and Removing</a></h2>
<p>List all scheduled agents with:</p>
<pre><code class="language-bash">taskter agent schedule list
</code></pre>
<p>Remove a schedule:</p>
<pre><code class="language-bash">taskter agent schedule remove --id 1
</code></pre>
<h2 id="running-the-scheduler"><a class="header" href="#running-the-scheduler">Running the Scheduler</a></h2>
<p>Start the scheduler loop with:</p>
<pre><code class="language-bash">taskter scheduler run
</code></pre>
<p>The scheduler will execute agents at the configured times and update tasks just as if <code>task execute</code> was run manually.
When multiple tasks are assigned to the same agent, the scheduler now runs them
concurrently so long-running jobs don't block each other.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-providers"><a class="header" href="#model-providers">Model Providers</a></h1>
<p>Taskter’s agent system is model‑agnostic. A provider layer adapts the neutral
agent loop to a specific LLM API. Providers convert between Taskter’s message
history and the provider’s wire format, and translate responses into either a
text completion or a tool call.</p>
<p>All provider requests and responses are mirrored to <code>.taskter/api_responses.log</code>
so that you can inspect the exact JSON being exchanged when debugging a new
integration.</p>
<h2 id="built-in-providers"><a class="header" href="#built-in-providers">Built-in Providers</a></h2>
<ul>
<li>Gemini (default): selected when <code>agent.model</code> starts with <code>gemini</code>.
<ul>
<li>Env var: <code>GEMINI_API_KEY</code></li>
<li>Code: <code>src/providers/gemini.rs</code></li>
</ul>
</li>
<li>OpenAI: selected when <code>agent.model</code> starts with <code>gpt-4</code>, <code>gpt-5</code>, <code>gpt-4o</code>, <code>gpt-4.1</code>, <code>o1</code>, <code>o3</code>, <code>o4</code>, or <code>omni</code>.
<ul>
<li>Env var: <code>OPENAI_API_KEY</code></li>
<li>Code: <code>src/providers/openai.rs</code></li>
<li>APIs:
<ul>
<li>Chat Completions: used for models like <code>gpt-4o</code> and <code>gpt-4o-mini</code>. Tools are passed as <code>{"type":"function","function":{...}}</code> and responses carry <code>choices[0].message.tool_calls[]</code>.</li>
<li>Responses API: used for <code>gpt-4.1</code>, <code>gpt-5</code>, <code>o-series</code>, and Omni models. Input is an item list; tool calls arrive as <code>{"type":"function_call", name, arguments, call_id}</code> in <code>output[]</code> and you must append both the <code>function_call</code> and a <code>function_call_output</code> item with the same <code>call_id</code>.</li>
</ul>
</li>
<li>Optional overrides:
<ul>
<li><code>OPENAI_BASE_URL</code> to point at a proxy (<code>https://api.openai.com</code> by default)</li>
<li><code>OPENAI_CHAT_ENDPOINT</code> / <code>OPENAI_RESPONSES_ENDPOINT</code> for full URL control</li>
<li><code>OPENAI_REQUEST_STYLE=chat|responses</code> to force the request format</li>
<li><code>OPENAI_RESPONSE_FORMAT</code> containing either a JSON blob (e.g. <code>{"type":"json_object"}</code>) or shorthand (<code>json_object</code>)</li>
</ul>
</li>
</ul>
</li>
<li>Ollama: selected when <code>agent.model</code> starts with <code>ollama:</code>, <code>ollama/</code>, or <code>ollama-</code>.
<ul>
<li>Env var: <code>OLLAMA_BASE_URL</code> (defaults to <code>http://localhost:11434</code>)</li>
<li>Code: <code>src/providers/ollama.rs</code></li>
<li>Uses the local <code>/api/chat</code> endpoint and mirrors the Chat Completions tool schema.</li>
</ul>
</li>
</ul>
<h2 id="configure-a-provider"><a class="header" href="#configure-a-provider">Configure a Provider</a></h2>
<ul>
<li>Choose a model string when creating/updating an agent (e.g. <code>gemini-2.5-pro</code>, <code>gpt-4.1</code>, <code>o1-mini</code>, or <code>ollama:llama3</code>).</li>
<li>Set the provider explicitly when running CLI commands by passing <code>--provider gemini|openai|ollama</code>. To clear a stored provider, use <code>taskter agent update --provider none …</code>; new agent creation does not accept <code>none</code>. When no provider is stored Taskter falls back to model-name heuristics.</li>
<li>Export the provider’s API key environment variable before running agents.
<ul>
<li>Gemini:
<pre><code class="language-bash">export GEMINI_API_KEY=your_key_here
</code></pre>
</li>
<li>OpenAI:
<pre><code class="language-bash">export OPENAI_API_KEY=your_key_here
</code></pre>
</li>
<li>Ollama does not require an API key. Optionally set <code>OLLAMA_BASE_URL</code> if your daemon listens somewhere other than <code>http://localhost:11434</code>.</li>
</ul>
</li>
</ul>
<p>If no valid API key is present, Taskter runs in offline mode and only executes
built-in tools.</p>
<h2 id="add-a-new-provider"><a class="header" href="#add-a-new-provider">Add a New Provider</a></h2>
<p>Implement the <code>ModelProvider</code> trait and register it in <code>select_provider</code>.</p>
<ol>
<li>Create a file under <code>src/providers/</code>, e.g. <code>my_provider.rs</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::{json, Value};
use anyhow::Result;
use crate::agent::Agent;
use super::{ModelAction, ModelProvider};

pub struct OpenAIProvider;

impl ModelProvider for OpenAIProvider {
    fn name(&amp;self) -&gt; &amp;'static str { "openai" }
    fn api_key_env(&amp;self) -&gt; &amp;'static str { "OPENAI_API_KEY" }

    fn build_history(&amp;self, agent: &amp;Agent, user_prompt: &amp;str) -&gt; Vec&lt;Value&gt; {
        vec![json!({
            "role": "user",
            "content": [
                {"type": "text", "text": format!("System: {}\\nUser: {}", agent.system_prompt, user_prompt)}
            ]
        })]
    }

    fn append_tool_result(&amp;self, history: &amp;mut Vec&lt;Value&gt;, tool: &amp;str, _args: &amp;Value, tool_response: &amp;str) {
        history.push(json!({
            "role": "tool",
            "content": [{
                "type": "tool_result",
                "name": tool,
                "content": tool_response
            }]
        }));
    }

    fn tools_payload(&amp;self, agent: &amp;Agent) -&gt; Value {
        // Map our FunctionDeclaration to OpenAI tools schema
        json!(agent.tools.iter().map(|t| {
            json!({
                "type": "function",
                "name": t.name,
                "description": t.description,
                "parameters": t.parameters,
                "strict": true
            })
        }).collect::&lt;Vec&lt;_&gt;&gt;())
    }

    fn endpoint(&amp;self, _agent: &amp;Agent) -&gt; String {
        "https://api.openai.com/v1/responses".to_string()
    }

    fn request_body(&amp;self, history: &amp;[Value], tools: &amp;Value) -&gt; Value {
        json!({
            "model": "gpt-4.1",
            "input": history,
            "tools": tools
        })
    }

    fn parse_response(&amp;self, v: &amp;Value) -&gt; Result&lt;ModelAction&gt; {
        if let Some(tc) = v["output"][0].get("tool_calls").and_then(|x| x.get(0)) {
            let name = tc["function"]["name"].as_str().unwrap_or_default().to_string();
            let args = tc["function"]["arguments"].clone();
            return Ok(ModelAction::ToolCall { name, args });
        }
        // Fallback to text content
        let text = v["output_text"].as_str().unwrap_or("").to_string();
        Ok(ModelAction::Text { content: text })
    }

    fn headers(&amp;self, api_key: &amp;str) -&gt; Vec&lt;(String, String)&gt; {
        vec![
            ("Authorization".into(), format!("Bearer {}", api_key)),
            ("Content-Type".into(), "application/json".into()),
        ]
    }
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Register it in <code>select_provider</code> inside <code>src/providers/mod.rs</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn select_provider(agent: &amp;Agent) -&gt; Box&lt;dyn ModelProvider + Send + Sync&gt; {
    let model = agent.model.to_lowercase();
    if model.starts_with("gemini") {
        Box::new(gemini::GeminiProvider)
    } else if model.starts_with("gpt-") {
        Box::new(openai::OpenAIProvider)
    } else {
        Box::new(gemini::GeminiProvider)
    }
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Set the API key and choose a matching model:</li>
</ol>
<pre><code class="language-bash">export OPENAI_API_KEY=your_key
# Example agent
taskter agent add --prompt "Be helpful" --tools run_bash --model my-model --provider openai
</code></pre>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>The agent loop is neutral: it asks a provider for one step, executes a tool
if requested, and appends the result via the provider to maintain the correct
message format.</li>
<li>Providers must ensure tools are represented in the target API’s expected
schema and that responses are robustly parsed into <code>ModelAction</code>.</li>
<li>See <code>src/providers/gemini.rs</code> and <code>src/providers/openai.rs</code> as complete reference implementations.</li>
</ul>
<h3 id="openai-responses-tool-calling-flow"><a class="header" href="#openai-responses-tool-calling-flow">OpenAI Responses: Tool Calling Flow</a></h3>
<p>The Responses API differs from Chat Completions. A typical multi‑turn flow:</p>
<ol>
<li>Send input as a list (start with user):
<pre><code class="language-json">[
  {"role":"user", "content":[{"type":"input_text","text":"Use run_bash to echo hello"}]}
]
</code></pre>
</li>
<li>Model returns an <code>output</code> array which can include <code>{"type":"function_call", "name":"run_bash", "arguments":"{\"command\":\"echo hi\"}", "call_id":"call_123"}</code>.</li>
<li>Execute the tool, then append to your input list:
<pre><code class="language-json">{"type":"function_call","call_id":"call_123","name":"run_bash","arguments":"{\"command\":\"echo hi\"}"},
{"type":"function_call_output","call_id":"call_123","output":"hello"}
</code></pre>
</li>
<li>Call the Responses API again with the expanded <code>input</code> and the same <code>tools</code>. The model will produce a final <code>message</code> with <code>output_text</code>.</li>
</ol>
<p>Taskter automates these steps inside the provider, including the call_id wiring and multi‑turn loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-files"><a class="header" href="#data-files">Data Files</a></h1>
<p>Taskter keeps all project state inside a <code>.taskter</code> directory. This folder is created when you run <code>taskter init</code>.
The following files are stored there and are automatically updated by Taskter.</p>
<h2 id="boardjson"><a class="header" href="#boardjson">board.json</a></h2>
<p>Holds the Kanban board in JSON format. The file contains all tasks with their status, descriptions and assigned agent. It is rewritten whenever you add, edit or complete tasks from the CLI or TUI.</p>
<h2 id="agentsjson"><a class="header" href="#agentsjson">agents.json</a></h2>
<p>Stores the list of agents. Each agent entry records the system prompt, available tools, model and optional schedule. The file is created on demand and modified by the various <code>agent</code> subcommands.</p>
<h2 id="okrsjson"><a class="header" href="#okrsjson">okrs.json</a></h2>
<p>Contains your objectives and key results. Commands under <code>taskter okrs</code> load and save this file.</p>
<h2 id="logslog"><a class="header" href="#logslog">logs.log</a></h2>
<p>Plain text log with timestamps. New lines are appended when you run <code>logs add</code> or when agents execute tasks.</p>
<h2 id="descriptionmd"><a class="header" href="#descriptionmd">description.md</a></h2>
<p>Markdown file describing the project. <code>taskter init</code> creates a placeholder that you can edit manually or through the TUI.</p>
<h2 id="email_configjson"><a class="header" href="#email_configjson">email_config.json</a></h2>
<p>Optional email credentials used by the <code>send_email</code> tool. Place it in the directory if agents need to send messages. The exact keys are documented in the <a href="configuration.html">Configuration</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>This chapter describes runtime configuration files and environment variables used by Taskter.</p>
<h2 id="email-configuration-file"><a class="header" href="#email-configuration-file">Email configuration file</a></h2>
<p>Email-based tools expect credentials in <code>.taskter/email_config.json</code> inside your project. Every agent reads the same file.</p>
<pre><code class="language-json">{
  "smtp_server": "smtp.example.com",
  "smtp_port": 587,
  "username": "user@example.com",
  "password": "secret",
  "imap_server": "imap.example.com",  // optional
  "imap_port": 993                    // optional
}
</code></pre>
<p>Currently only the SMTP fields are used by the <code>send_email</code> tool. The IMAP keys are accepted for future extensions. No default values are provided, so fill in the details that match your mail provider.</p>
<p>If the file is missing the tool outputs <code>Email configuration not found</code>. When Taskter runs without a <code>GEMINI_API_KEY</code>, email tools are skipped entirely so the file is not required for tests.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p>Agents use a provider abstraction. Each provider defines its own API key env var:</p>
<ul>
<li><code>GEMINI_API_KEY</code> — API key for the Gemini provider.</li>
<li><code>OPENAI_API_KEY</code> — API key when using an OpenAI provider (if added).</li>
<li><code>SEARCH_API_ENDPOINT</code> — custom endpoint for the <code>web_search</code> tool. Defaults to <code>https://api.duckduckgo.com</code>.</li>
</ul>
<p>Export the relevant variable directly in your shell or via Docker Compose. For Gemini:</p>
<pre><code class="language-bash">export GEMINI_API_KEY=your_key_here
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Contributions are welcome! This guide will help you get started with setting up your development environment and submitting your changes.</p>
<h2 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h2>
<p>To contribute to Taskter, you'll need to have Rust and Cargo installed. If you haven't already, follow the instructions at <a href="https://www.rust-lang.org/tools/install">rust-lang.org</a>.</p>
<p>Once you have Rust set up, clone the repository and navigate to the project directory:</p>
<pre><code class="language-bash">git clone https://github.com/tomatyss/taskter.git
cd taskter
</code></pre>
<h2 id="pre-commit-checks"><a class="header" href="#pre-commit-checks">Pre-commit checks</a></h2>
<p>Before committing any changes, please run the pre-commit script to ensure your code is formatted, linted, and passes all tests:</p>
<pre><code class="language-bash">./scripts/precommit.sh
</code></pre>
<p>You can also automatically apply formatting and Clippy suggestions with:</p>
<pre><code class="language-bash">./scripts/fix_lints.sh
</code></pre>
<p>You can also set this up as a pre-commit hook to run automatically:</p>
<pre><code class="language-bash">ln -s ../../scripts/precommit.sh .git/hooks/pre-commit
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The documentation is built with <a href="https://rust-lang.github.io/mdBook/">mdBook</a>. To contribute to the docs, edit the Markdown files under the <code>docs/src/</code> directory.</p>
<p>When you're ready, open a pull request with your changes. The GitHub Actions workflow will automatically build and publish the book when your changes are merged into the <code>main</code> branch.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
